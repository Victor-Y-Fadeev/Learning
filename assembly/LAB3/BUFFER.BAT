	; @echo off
	; goto l1
	.model	tiny
	.386
	.code
	org	100h
_:
	jmp start

string  db '     ', 13,10,'$'		; первые 2 скан код, вторые 2 ascii символ
start:

	mov bx, [0:41Ah]		; адрес начала буфера
	mov cx, [0:41Ch]		; адрес хвоста буфера
	cmp cx, bx				; сравниваю голову и хвост, если равны то буфер пустой, результат 0 (правда)
	je start				; je переход если выполняется условие выше, иначе продолжает дальше

	mov ah, 00h				; (требование функции)
	int 16h					; вызов функции чтения символа с клавиатуры, в al - символ, ah - скан код	

	mov cx, ax				; сохраняем результат

	lea di, string			; копируем в di адрес на начало строки
	mov bl, ah				; кладем в bl скан код
	call h2					; вызываем свою функцию h2 (см. ниже)

	mov ax, cx				; восстанавливаем значение считанного символа	

	cmp al, 1Bh				; проверяем нажатие ESC
	je exit
	cmp al, 24h				; проверяем нажатие $ (символ конца строки)
	je exit

print:
	inc di					; сдвигаем указатель на строку на 1 (пробел)
	stosb					; записывает ascii символ в строку

	mov ah, 09h				; выбираем 09h - функцию печати
	lea dx, string			; параметр функции печати (ссылка на строку)
	int 21h					; 21 прерывание (вызов функции из ah)

	cli						; отключить прерывания

	push es					; сохраняем на стеке локальную область памяти 
	push 0					; кладем на стек 0
	pop es					; считываем 0 со стека в es

	mov al, es:[41Ah]		; кладем голову в al
	mov es:[41Ch], al		; приравниваем хвост буфера к голове

	pop es					; восстанавливаем локальну память

	sti						; включить прерывания

	jmp start

h2: 
	mov al, bl			; копируем скан код в al

	shr al, 4			; сдвигаем значение в al на 4 разряда вправо (нулями)
	call h1				; вызываем h1

	mov al, bl 

h1:
	and ax, 0fh 
	cmp al, 10  
	sbb al, 69h 
	das	    
	stosb				; записывает в (es:di) содержаение al (добавляем в нашу строку значение скан кода)
	
exit:   ret
end _	
; :l1
; tasm /m5 buffer.bat
; tlink /x/t buffer.obj
; del buffer.obj

